// 空间类的实现
#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;

#include <windows.h>

#include "XWawaSpace.h"

XWawaSpace::XWawaSpace()
{
	width = XWAWAROOM_WIDTH_MAX;
	height = XWAWAROOM_HEIGHT_MAX;

	init();
}

XWawaSpace::XWawaSpace(int w, int h)
{
	if (w>XWAWAROOM_WIDTH_MAX) w = XWAWAROOM_WIDTH_MAX;
	if (h>XWAWAROOM_HEIGHT_MAX) h = XWAWAROOM_HEIGHT_MAX;

	width = w;
	height = h;

	init();
}

void XWawaSpace::init()
{
	int row, col;
	for (row=0; row<height; row++)
	{
		for (col=0; col<width; col++)
		{
			if (col == 0 || col == width-1 || row == 0 || row == height-1)
				data[row][col] = XWAWAROOM_WALL;
			else
				data[row][col] = XWAWAROOM_EMPTY;
		}
	}

	wawa_cx = height-2;
	wawa_cy = 1;
}

void XWawaSpace::init(char newdata[XWAWAROOM_HEIGHT_MAX][XWAWAROOM_WIDTH_MAX])
{
	int row, col;
	for (row=0; row<height; row++)
	{
		for (col=0; col<width; col++)
		{
			if (col == 0 || col == width-1 || row == 0 || row == height-1)
				data[row][col] = XWAWAROOM_WALL;
			else
				data[row][col] = newdata[row][col];
		}
	}

	wawa_cx = height-2;
	wawa_cy = 1;
}

void XWawaSpace::paint()
{
	system("cls");

	int row, col;
	for (row=0; row<height; row++)
	{
		for (col=0; col<width; col++)
		{
			if (row == wawa_cx && col == wawa_cy)
				if (data[row][col] == XWAWAROOM_BEAN)
					cout<<XWAWAROOM_WAWAANDBEAN<<" ";
				else
					cout<<XWAWAROOM_WAWA<<" ";
			else
				cout<<data[row][col]<<" ";
		}
		cout<<endl;
	}
}

void XWawaSpace::repaint()
{
	paint();
}

void XWawaSpace::getRect(int &width, int &height)
{
	width = this->width;
	height = this->height;
}

void XWawaSpace::setPoint(int x, int y, char value)
{
	data[x][y] = value;

	repaint();
}

char XWawaSpace::getPoint(int x, int y)
{
	return data[x][y];
}

void XWawaSpace::setWawaPos(int x, int y)
{
	wawa_cx = x;
	wawa_cy = y;
}

void XWawaSpace::getWawaPos(int &x, int &y)
{
	x = wawa_cx;
	y = wawa_cy;
}

bool XWawaSpace::moveWawa(int dir)
{
	if (!isClear(dir))
		return false;

	switch (dir)
	{
	case XWAWAROOM_DIR_UP:
		setWawaPos(wawa_cx-1, wawa_cy);
		break;
	case XWAWAROOM_DIR_DOWN:
		setWawaPos(wawa_cx+1, wawa_cy);
		break;
	case XWAWAROOM_DIR_LEFT:
		setWawaPos(wawa_cx, wawa_cy-1);
		break;
	case XWAWAROOM_DIR_RIGHT:
		setWawaPos(wawa_cx, wawa_cy+1);
		break;
	}

	Sleep(300);
	repaint();

	return true;
}

bool XWawaSpace::isClear(int dir)
{
	bool result = false;

	switch (dir)
	{
	case XWAWAROOM_DIR_UP:
		if (data[wawa_cx-1][wawa_cy] != XWAWAROOM_WALL)
			result = true;
		break;
	case XWAWAROOM_DIR_DOWN:
		if (data[wawa_cx+1][wawa_cy] != XWAWAROOM_WALL)
			result = true;
		break;
	case XWAWAROOM_DIR_LEFT:
		if (data[wawa_cx][wawa_cy-1] != XWAWAROOM_WALL)
			result = true;
		break;
	case XWAWAROOM_DIR_RIGHT:
		if (data[wawa_cx][wawa_cy+1] != XWAWAROOM_WALL)
			result = true;
		break;
	}

	return result;
}

bool XWawaSpace::isEmpty()
{
	bool result = true;

	int row, col;
	for (row=1; row<height-1; row++)
	{
		for (col=1; col<width-1; col++)
		{
			if (data[row][col] == XWAWAROOM_BEAN)
			{
				result = false;
				break;
			}
		}
	}

	return result;
}

void XWawaSpace::build(int task)
{
	switch (task)
	{
	case 0:
		{
		char data[XWAWAROOM_HEIGHT_MAX][XWAWAROOM_WIDTH_MAX] = {
			XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL
		};
		width = XWAWAROOM_WIDTH_MAX;
		height = XWAWAROOM_HEIGHT_MAX;
		init(data);
		break;
		}
	case 1:
		{
		char data[XWAWAROOM_HEIGHT_MAX][XWAWAROOM_WIDTH_MAX] = {
			XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL
		};
		width = XWAWAROOM_WIDTH_MAX;
		height = XWAWAROOM_HEIGHT_MAX;
		init(data);
		break;
		}
	case 2:
		{
		char data[XWAWAROOM_HEIGHT_MAX][XWAWAROOM_WIDTH_MAX] = {
			XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_EMPTY,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_EMPTY,XWAWAROOM_BEAN,XWAWAROOM_WALL,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_WALL,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_WALL,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_WALL,XWAWAROOM_BEAN,XWAWAROOM_BEAN,XWAWAROOM_WALL,
			XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL,XWAWAROOM_WALL
		};
		width = XWAWAROOM_WIDTH_MAX;
		height = XWAWAROOM_HEIGHT_MAX;
		init(data);
		break;
		}
	case 3:
		{
		char data[XWAWAROOM_HEIGHT_MAX][XWAWAROOM_WIDTH_MAX];
		int width, height;
		getRect(width, height);
		int row, col;
		for (row=0; row<height; row++)
		{
			for (col=0; col<width; col++)
			{
				if (row==0 || row==height-1 || col==0 || col==width-1)
					data[row][col] = XWAWAROOM_WALL;
				else
					data[row][col] = XWAWAROOM_EMPTY;
			}
		}
		// 确定一组障碍的位置和高度，并设置障碍
		srand(time(NULL));
		int obstacle_height = 0;
		for (col=2; col<width-2; col++)
		{
			// 随机确定当前列是否有障碍
			// 如果有障碍则随机确定其高度
			if (rand()%2)
			{
				obstacle_height = rand()%(height-3)+1;
				for (row=height-obstacle_height-1; row<height-1; row++)
					data[row][col] = XWAWAROOM_WALL;

				if (col+1<width-2)
				{
					col++;
					data[height-2][col] = XWAWAROOM_BEAN;
				}
			}
			else
			{
				data[height-2][col] = XWAWAROOM_BEAN;
			}
		}
		data[height-2][col] = XWAWAROOM_BEAN;
		init(data);
		break;
		}
	case 4:
		{
		char data[XWAWAROOM_HEIGHT_MAX][XWAWAROOM_WIDTH_MAX];
		int width, height;
		getRect(width, height);
		int row, col;
		for (row=0; row<height; row++)
		{
			for (col=0; col<width; col++)
			{
				if (row==0 || row==height-1 || col==0 || col==width-1)
					data[row][col] = XWAWAROOM_WALL;
				else
					data[row][col] = XWAWAROOM_EMPTY;
			}
		}
		// 确定一组障碍的位置和高度，并设置障碍
		srand(time(NULL));
		int obstacle_height = 0;
		for (col=2; col<width-1; col++)
		{
			// 随机确定当前列是否有障碍
			// 如果有障碍则随机确定其高度
			if (rand()%2)
			{
				obstacle_height = rand()%(height-3)+1;
				for (row=height-obstacle_height-1; row<height-1; row++)
					data[row][col] = XWAWAROOM_WALL;
			}
			else
			{
				data[height-2][col] = XWAWAROOM_BEAN;
			}
		}
		init(data);
		break;
		}
	default:
		init();
		break;
	}

	paint();
}

bool XWawaSpace::check()
{
	return isEmpty();
}

